# 函数极值与规划模型

> 国赛A题，美赛A题、B题、D题
>
> 优化策略、求最优解、贪心策略

## 1 线性规划模型

### 1.1 概述

<u>回顾中学的线性规划</u>：

- 我们可能还记得中学课本里面有一个边缘化的知识——==**线性规划**==
  大家还能回忆起线性规划究竟是用来做什么的吗？
  求一个**线性目标函数**在**线性可行域**内的：==**最值问题**==

  <img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220707145446478.png" alt="image-20220707145446478" style="zoom:50%;" />

- 线性规划的典型应用有哪些？

  - 配送运输问题，选大车还是小车
  - 生产规划问题，每种原料各买多少
  - 几何切割问题，切割长宽多少
  - 买卖利润问题，这种方案下我能挣多少

- 关于中学线性规划解法的思考

  - 以前我们做的时候可以直接带交点进去算
  - **问题的线性**和**条件的线性**，即**线性特征**，让我们可以这样去做

- 给中学的线性规划增加难度：

  - 有更多的**变量**，不只两个，坐标系画不出来
  - 目标函数变成**非线性**
  - 可行域中不只有**不等式**，还有**等式**
  - 变量还有一个特殊的**约束**

  >你还会解这样的问题吗？最优解还一定会在交点或边界取到吗?？还能通过作图求吗？最优解还一定存在吗？

- ==线性规划的本质==：

  - ==问题是线性的==
  - ==约束是线性的==

### 1.2 线性代数基本概念

<u>向量</u>：

- n维向量
- 不只三维，还可以有更多维度
- 引入n维向量的目的：
  - 通过**代数方法**解决**几何问题**

<u>向量的基本运算</u>：
<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220707150842268.png" alt="image-20220707150842268" style="zoom:67%;" />

> 内积结果向量的方向可以用**右手定则**去判断

<u>矩阵</u>：

- 数的集合是向量，向量的集合形态就是矩阵
- 向量数乘：
  <img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220707151059918.png" alt="image-20220707151059918" style="zoom:67%;" />

<u>行列式</u>：

- 行列式就是一个数，可以理解为**方阵的模**

- 二阶和三阶行列式有**公式**

- 高阶的可以用**展开定理**：

  <img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220707151232606.png" alt="image-20220707151232606" style="zoom:60%;" />

  > 代数余子式：
  >
  > <img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220707151613215.png" alt="image-20220707151613215" style="zoom:80%;" />

<u>矩阵的运算</u>：

- 线性运算
  <img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220707152025184.png" alt="image-20220707152025184" style="zoom:67%;" />

  > 矩阵的线性运算与向量类似，因为本身就是向量的线性组合

- 乘法
  <img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220707152122636.png" alt="image-20220707152122636" style="zoom:67%;" />

- 逆运算

  <img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220707152158217.png" alt="image-20220707152158217" style="zoom:60%;" />

<u>利用`python`进行矩阵的相关运算</u>：

- 基本运算
  - 见python数据分析之numpy

- 求一次方程组的解

  ```python
  import numpy as np
  
  A = np.array([[10, -1, -2],
                [-1, 10, -2],
                [-1, -1, 5]])
  b = np.array([72, 83, 42])
  # inv_A = np.linalg.inv(A)
  # x = inv_A @ B
  x = np.linalg.solve(A, b)
  print(x)
  
  from sympy import symbols, Eq, solve
  
  x, y, z = symbols('x y z')
  eqs = [Eq(10 * x - y - 2 * z, 72),
         Eq(-x + 10 * y - 2 * z, 83),
         Eq(-x - y + 5 * z, 42)]
  print(solve(eqs, [x, y, z]))
  ```

  - 主要通过scipy sympy numpy这三个库就能实现各种各样的一次方程组求解。

  - `sympy`主要用于**符号解**

    > 目前的理解就是，有不只一个解的线性方程组需要用**符号解**去求解

  - `numpy`和`scipy`主要用于**数值解**

### 1.3 线性规划的标准形式

#### 1.3.1 规范形式

> 程序设计时应用较多

目标函数是决策变量的线性组合，有不等关系，等量关系，变量范围，求目标极小值

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220711211604247.png" alt="image-20220711211604247" style="zoom:67%;" />

- **不等式**组条件的矩阵化 
- **方程**组条件的矩阵化 
- 每个变量自己的**取值范围** 
- **目标函数**的向量化 
- 求**极值** 

==要点：决策变量，目标函数，约束条件==

#### 1.3.2 一般形式

> 遇到代数推导等处理特殊问题时会用

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220711212039455.png" alt="image-20220711212039455" style="zoom:80%;" />

> X到$\overset{\sim}{X}$的解释：
>
> <img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220711212100952.png" alt="image-20220711212100952" style="zoom:67%;" />

#### 1.3.3 对线性规划标准形式的理解

- 问题是线性的极值
- 约束条件本应该是小于等于，这是通用的，改成等于是利用问题的线性 
- 存在不等约束时变换可应用**松弛变量** 
- 规划问题的核心在于==决策变量，目标函数和约束条件==

#### 1.3.4 求解简单线性规划问题举例

![image-20220711212832756](%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220711212832756.png)

一些处理：

- 规范形式是极小值，这里目标函数要极大值，可以加个负号
- 规范形式的不等式都是小于等于，这里有大于等于，可以加个负号

`scipy.optimize.linprog`的调用格式：

```python
scipy.optimize.linprog(目标函数的系数向量, 
                       不等式的描述方式（系数，b）, 
                       方程的描述方式（系数，b）, 
                       变量约束)
```

代码：

```python
import numpy as np
from scipy.optimize import linprog

c = np.array([-2, -3, 5])
Aeq = np.array([[1, 1, 1]])
beq = np.array([7])
A = np.array([
    [-2, 5, -1],
    [1, 3, 1],
])
b = np.array([-10, 12])
x1, x2, x3 = (0, None), (0, None), (0, None)

res = linprog(c, A, b, Aeq, beq, (x1, x2, x3))
print(res)
print(-res.fun)
print(res.x)

```

### 1.4 相关数学原理

#### 1.4.1 单纯形法

回顾中学阶段，我们求线性规划的时候都是解方程然后直接带点进去，直线与直线之间两两相交就有交点，这其实就是**单纯形法**的雏形。现在的线性规划方程组是不一定存在交点或者不唯一解的。 

线性代数中我们会知道：解方程组的时候是可以用**向量和基分解的思想**解决的 

==**单纯形法**的思想就是：**固定变量**，不断变换**基向量**求方程组的解带入，看是不是最优解，不是就更新迭代现阶段的解==

这就可以解释为什么在线性规划问题中要引入**松弛变量**

- 为什么我们需要引入松弛变量呢？原因很简单，因为**单纯形法**要求约束条件都为等式（且要求所有变量非负），那么要是有不等式约束怎么办？那我们就把不等式约束**通过引入松弛变量变为等式约束**，这样一来带有不等式约束的线性规划问题就也能用单纯形法解决了。

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220711215343503.png" alt="image-20220711215343503" style="zoom:70%;" />

> 总结：什么情况下在线性规划中引入松弛变量？
>
> - 当你需要将线性规划化成标准形式/一般形式的时候
>
> - 当你遇到**绝对值**问题的时候
>
>   > 比如，可以将$|x_1-x_2|\le2$改成$x_1=x_2+\epsilon,-2\le\epsilon\le2$
>
> - 当你遇到不等式过多甚至到了**非线性**的不等关系的时候

#### 1.4.2 蒙特卡洛法

> 单纯形法求解比较精确，如果只是想要一个可行解，可以用蒙特卡洛法

蒙特卡洛方法就是在**可行域范围内生成大批量随机数据点**，观测这些数据点在什么位置取得近似最优。但是生成点因为是随机的，所以肯定是要生成大批量数据去做计算的，然后求出来的也只是数值的近似最优解，更多的适用于解**非线性问题**，线性问题是能得到准确解的。

> 总结：引入松弛变量的规划求解
>
> - 蒙特卡洛法 
> - 分支定界法 
> - 单纯形法


## 2 非线性规划模型

### 2.1 概述

相比于线性问题：

- 在线性规划的基础上，**目标函数**可以非线性，**限制条件**可以非线性，包括非线性的不等式和非线性的等式。

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220711222758413.png" alt="image-20220711222758413" style="zoom:80%;" />

### 2.2 二次规划问题

#### 2.2.1 二次规划的基本形式

目标函数形式如果是一个二次函数那就是一个二次规划：

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220711222949616.png" alt="image-20220711222949616" style="zoom:80%;" />

#### 2.2.2 数学知识补充

多元函数的微分：

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220711223507105.png" alt="image-20220711223507105" style="zoom:80%;" />

多元函数的极值求解：

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220711223528789.png" alt="image-20220711223528789" style="zoom:80%;" />

拉格朗日乘子法与KKT：

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220711223637049.png" alt="image-20220711223637049" style="zoom:80%;" />

- 用**KKT条件**处理不等式约束

  > 之前学过，引入**松弛变量**也可以处理不等式约束；
  >
  > 这里使用KKT条件，没有讲解原理，直接套用即可

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220711223754891.png" alt="image-20220711223754891" style="zoom:80%;" />

> $\mu g(X^*)=0$是为了不让不等式条件影响到极值

#### 2.2.3 二次规划的求解举例

数学描述举例：

![image-20220711224328428](%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220711224328428.png)

**KKT条件是求解线束优化问题的通用方法**

实际场景举例：

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220712101056401.png" alt="image-20220712101056401" style="zoom:80%;" />

- scipy求解：

  > 官方文档：
  >
  > https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html

  ```python
  from scipy.optimize import minimize
  import numpy as np
  
  
  def func(x):
      return 10.5 + 0.3 * x[0] + 0.32 * x[1] + 0.32 * x[2] + 0.0007 * x[0] ** 2 + 0.0004 * x[1] ** 2 + 0.00045 * x[2] ** 2
  
  
  cons = ({'type': 'eq', 'fun': lambda x: x[0] + x[1] + x[2] - 700})
  b1, b2, b3 = (100, 200), (120, 250), (150, 300)
  x0 = np.array([100, 200, 400])  # 初始猜测解
  res = minimize(func, x0, bounds=(b1, b2, b3), constraints=cons)
  print(res)
  ```

  > 注：关于`method`参数
  >
  > - Method BFGS cannot handle constraints nor bounds.
  > - Method L-BFGS-B cannot handle constraints.
  > - ...
  >
  > 所以还是建议保持默认，这样会根据是否有条件约束和变量约束来选择合适的方法

  - res.fun：最优解
  - res.hess_inv：偏导数
  - res.jac：梯度
  - res.x：最优解

- 遗传算法求解：之后再次遇到遗传算法，再认真学一遍

  > 要先`pip install scikit-opt`

  ```python
  from sko.GA import GA
  
  
  def func(x):
      return 10.5 + 0.3 * x[0] + 0.32 * x[1] + 0.32 * x[2] + 0.0007 * x[0] ** 2 + 0.0004 * x[1] ** 2 + 0.00045 * x[2] ** 2
  
  
  def cons_eq(x):
      return x[0] + x[1] + x[2] - 700
  
  
  ga = GA(func=func, n_dim=3, size_pop=500, max_iter=1000, constraint_eq=(cons_eq,),
          lb=[100, 120, 150], ub=[200, 250, 300])
  print(ga.run())
  ```


### 2.3 非线性规划案例

#### 2.3.1 案例1

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220712110308522.png" alt="image-20220712110308522" style="zoom:80%;" />

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220712110733396.png" alt="image-20220712110733396" style="zoom:80%;" />

> 如果将不等号改成等号，模型的效果会变好吗？

#### 2.3.2 案例2

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220712110830497.png" alt="image-20220712110830497" style="zoom:67%;" />

- 刚性约束与柔性约束

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220712205854848.png" alt="image-20220712205854848" style="zoom:67%;" />

- 用**未满误差**和**过盈误差**来描述“不超过”和“**尽可能**”

  > 在本题中，“不超过”的两个约束都是**刚性约束**，“尽可能”的那个约束是**柔性约束**

  > :star:用在等式中的实际的数量，都是：$可计算数量+未满误差-过盈误差$，
  >
  > - 如果是刚性约束，就是只让未满的或过盈的达到极小值
  > - 如果是柔性约束，就是让$未满误差-过盈误差$达到极小值

- 引入了松弛变量，就可以大胆使用等式了

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220712210014570.png" alt="image-20220712210014570" style="zoom:67%;" />

## 3 整数规划模型

### 3.1 概述

什么是离散？什么是连续？ 

离散就是指问题的解或者自变量取值是整数式的，或者说取值是有穷的。 

连续就是指问题的取值是连续式的，可以是任意的浮点数形式。通常来讲连续问题会比离散问题更容易处理，因为离散问题会考虑到很多限制。 

如果给传统的非线性规划或者线性规划加上一个限制就是取值必须是整数，那么问题就是一个离散形式的优化模型。通常我们做离散优化的话**整数规划**比较多。 

但从计算机的数值计算方法考虑，**连续优化**问题的求解又基于**离散优化**的迭代。

整数规划的分类：

- 全部变量限制为整数的规划问题，称为纯整数规划；
- 部分变量限制为整数的规划问题，称为混合整数规划；
- 变量只取0或1的规划问题，称为0-1整数规划。

常见算法：

- **分枝定界法**：可求纯或混合整数线性规划。
- 割平面法：可求纯或混合整数线性规划。
- 隐枚举法：用于求解0- 1整数规划，有过滤法和分枝法。
- **匈牙利法**：解决指派问题(0-1规划特殊情形)。
- 蒙特卡罗法：求解各种类型规划。

### 3.2 0-1规划

#### 3.2.1 指派问题

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220712214730667.png" alt="image-20220712214730667" style="zoom:67%;" />

分支定界法：

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220712215353902.png" alt="image-20220712215353902" style="zoom:67%;" />

- 先按连续的线性规划问题来求解，再划分问题，直到得到整数最优解

匈牙利法：

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220712215544186.png" alt="image-20220712215544186" style="zoom:67%;" />

> 这个求解的过程目前我还不理解，但下面的案例中，代码的书写方式与结果的含义可以理解

#### 3.2.2 案例

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220712220025768.png" alt="image-20220712220025768" style="zoom:67%;" />

```python
from scipy.optimize import linear_sum_assignment
import numpy as np

T = np.array([
    [25, 29, 31, 42],
    [39, 38, 26, 20],
    [34, 27, 28, 40],
    [24, 42, 36, 23]])
row_ind, col_ind = linear_sum_assignment(T)
print(row_ind)
print(col_ind)
print(T[row_ind, col_ind])
print(T[row_ind, col_ind].sum())

```

- row_ind和col_ind：横坐标和纵坐标，每一个点分别代表某人做某项工作

## 4 动态规划

### 4.1 概述

动态规划的基本思想 ：

- 动态规划(Dynamic Programming)算法的核心思想是：**将大问题划分为小问题进行解决**，从而一步步获取最优解的处理算法 

- 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 

- 与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。

  > 即下一个子阶段的求解是**建立在上一个子阶段的解的基础上**，进行进一步的求解

- 动态规划可以通过填表的方式来逐步推进，得到最优解

状态空间与剪枝：

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713153952447.png" alt="image-20220713153952447" style="zoom:67%;" />

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713154001351.png" alt="image-20220713154001351" style="zoom:67%;" />

## 5 贪心策略

### 5.1 概述

贪心算法总是作出在当前看来是最好的选择。也就是说贪心算法并不从整体最优上加以考虑，它所作出的选择只是在某种意义上的局部最优选择。当然，我们希望贪心算法得到的最终结果也是整体最优的。 

贪心算法通过一系列的选择来得到一个问题的解。它所作的每一个选择都是当前状态下某种意义的最好选择，即贪心选择。希望通过每次所作的贪心选择导致最终结果是问题的一个最优解。这种启发式的策略并不总能奏效，然而在许多情况下确能达到预期的目的。解活动安排问题的贪心算法就是一个例子。下面我们着重讨论可以用贪心算法求解的问题的一般特征。 

对于一个具体的问题，我们怎么知道是否可用贪心算法来解此问题，以及能否得到问题的一个最优解呢?这个问题很难给予肯定的回答。但是，从许多可以用贪心算法求解的问题中我们看到它们一般具有两个重要的性质：贪心选择性质和最优子结构性质。

贪心和dp的联系是非常紧密的，我们先来分析一下贪心和dp的不同之处：

- dp是根据迁移过程的状态去推导下一个过程的状态，是有理论依据的，是讲道理的，通过每次完美的检验而得到最优解，关键是找最优子结构和重复子问题，书上一句原话：dp的子结构必须的独立的，而且是重叠的而贪心每次都只顾眼前最优，目光短浅，这种方式是不讲道理的，不想dp一样，还根据前面的迁移状态推导后面的子问题，比如最经典的01背包问题根据贪心策略，每次放进去的都是目前最优的，即目前价值最大的，直到背包装不下，但是这样放的话肯定是不如人意的，因为没有考虑到背包容量的问题，为什么呢？因为前面说过了，贪心策略只考虑当前最优解，它才不会去考虑什么背包容量的问题呢，它只管装价值最大的物品，这样是得不到最优解的，必须再加一个约束条件：背包容量，那么这个做法就变成了dp的做法了

### 5.2 编程

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713154930952.png" alt="image-20220713154930952" style="zoom:87%;" />

## 6 如何写出好的规划模型

数学建模题目的分类：

- 优化问题：重在模型建立，模型求解
- 数据问题：重在算法应用，结果叙述

如何建立好的模型：

- 知道到底在问什么
- 规划问题的难点往往在**目标函数**上
- 问题之间可以有联系，也可以并行解决

如何写好目标函数：

- 利用线性或非线性关系
- 利用求积与均值形式的函数
- 目标函数与约束条件可能并不独立 
- 可能需要用到积分或微分做目标函数
- 多个目标归一划，使用加权组合、求商等等方法

怎么找决策变量：

- 如果无法保证取值有穷，那么决策变量尽可能少
- 如果能抽象为0-1规划，那就用0-1规划

怎么找约束条件：

- 题目直接描述的
- 常识
- 根据题目背景进行文献检索

数学规划软件：杉树 lingo gurobi cplex 

# 微分方程与差分方程模型

## 1 微分方程的理论基础

### 1.1 微分

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713181409775.png" alt="image-20220713181409775" style="zoom:67%;" />

### 1.2 导数

一阶导数：

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713181431593.png" alt="image-20220713181431593" style="zoom:67%;" />

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713181445158.png" alt="image-20220713181445158" style="zoom:67%;" />

> 右边的图是$y=\frac1{1+e^x}$，其导数为$y'=y(1-y)$

高阶导数：

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713181512055.png" alt="image-20220713181512055" style="zoom:67%;" />

### 1.3 泰勒公式

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713181849716.png" alt="image-20220713181849716" style="zoom:67%;" />

### 1.4 常微分方程

一元常微分方程：

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713182229002.png" alt="image-20220713182229002" style="zoom:67%;" />

一阶常微分方程：

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713182251032.png" alt="image-20220713182251032" style="zoom:67%;" />

- 一阶常微分方程的通解形式：

  <img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713182532377.png" alt="image-20220713182532377" style="zoom:67%;" />

二阶常微分方程：

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713182707165.png" alt="image-20220713182707165" style="zoom:67%;" />

- 二阶常微分方程的通解形式：

  <img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713182907769.png" alt="image-20220713182907769" style="zoom:67%;" />

  > 差分方程举例：
  >
  > <img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713183004232.png" alt="image-20220713183004232" style="zoom:67%;" />

  <img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713183042333.png" alt="image-20220713183042333" style="zoom:80%;" />

  正确性证明：

  <img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713183218672.png" alt="image-20220713183218672" style="zoom:67%;" />

- 二阶常微分方程的特解：

  <img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713183352220.png" alt="image-20220713183352220" style="zoom:80%;" />

  <img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713183415309.png" alt="image-20220713183415309" style="zoom:67%;" />

## 2 常微分方程的python求解

### 2.1 概述

符号解与数值解：

- 为什么要提到符号解和数值解呢？解不就是解吗？方程的解难道不是就一个解就够了吗？ 

- 实际上，符号解就是以代数符号与运算的形式完整地写出解的代数式，强调**解的代数性** 

- 而数值解则是在给定方程的一些初始条件下我不按式子来，而是**算出一个数值**，这个数值可以不需要完完本本的精确，满足一定的要求就可以了。 

  > 举一个最简单的例子，如果我的方程得到的解与圆周率有关（暂且假设这个解是圆的周长吧）那么解析解也就是符号解必须表示为$x=0.32\pi$，但如果只是为了求一个数值解，那么可以在圆周率取3.14的精度限制下认为x=1.0048

大多数微分方程没有符号解/解析解：

- 我们此前介绍的一阶、二阶常系数线性微分方程通解的形式就是一种符号解 
- 但在科学与工程实际中我们遇到的微分方程形式会比这些基本形式更为复杂，条件也更多 
- 事实上多数情况下，大多数微分方程其实是求不出符号解的，只能在不同取值条件下求一个数值解 
- 那么如何编写算法去求数值解才能使精度尽可能提高呢？ 
- 数值解会随着初始条件而变化，怎么变化呢？函数值又与自变量之间怎么变化呢？ 
- 这就涉及到微分方程数值解的**演化问题**和**灵敏性分析**问题

Sympy简介：

- Sympy是一个数学符号运算库。能解决积分、微分方程等各种数学运算方法，用起来也是很简单，可以和Matlab媲美。

- Sympy.dsolve方法是解微分方程符号解的一种良好方式，而对于有初始值的微分方程问题，我 

  们通常在求出其通解形式后通过解方程组的方法得到参数，通过声明符号变量的方式求得最优解。

### 2.2 python求符号解代码

sympy中相关api：

- `symbols`
- `Eq`
- `diff`
- `dsolve`
- `solve`

例一：sympy求符号解

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713190914086.png" alt="image-20220713190914086" style="zoom:67%;" />

```python
from sympy import *

y = symbols('y', cls=Function)
x = symbols('x')
eq = Eq(y(x).diff(x, 2) + 2 * y(x).diff(x, 1) + y(x), x ** 2)
print(dsolve(eq, y(x)))

```

例二：sympy求数值解

- 先求符号解
- 再代入初值

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713191338091.png" alt="image-20220713191338091" style="zoom:67%;" />

```python
from sympy import *

y = symbols('y', cls=Function)
x = symbols('x')
eq = Eq(y(x).diff(x, 2) + 4 * y(x).diff(x, 1) + 29 * y(x), 0)
print(dsolve(eq, y(x)))
# 看到上面print的结果之后才能写出下面的代码
C1, C2 = symbols('C1 C2')
f = (C1*sin(5*x) + C2*cos(5*x))*exp(-2*x)
eqs = [
    f.subs(x, 0),
    f.diff(x).subs(x, 0) - 15
]
solve(eqs, [C1, C2])
print(solve(eqs, [C1, C2]))

```

### 2.3 python求数值解代码

Python求解微分方程的**数值解**需要应用scipy.odeint方法 

虽然很多情况下解不出符号解，但是自变量取不同取值时是可以获得一个一一对应的列表的。 

我们还可以将数值解和符号解对比，画图看看 

本质上内部ode是用到了**欧拉法**和**龙格库塔法**

一阶：

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220713193518224.png" alt="image-20220713193518224" style="zoom:80%;" />

```python
# 解 y' = x^2 + y^2
# 确定初值为 y(0) = 0
from scipy.integrate import odeint
from numpy import arange
def dy(y, x):
    return x*x + y*y
y0 = 0
xarray = arange(0, 10.5, 0.5)
odeint(dy, y0, xarray)
```

```python
# 解 y' = 1/(x^2 + 1) - 2*y^2
# 确定初值为 y(0) = 0
from scipy.integrate import odeint
from numpy import arange
import matplotlib.pyplot as plt
from jupyterthemes import jtplot
jtplot.style()
def dy(y, x):
    return 1/(x*x + 1) - 2*y*y
y0 = 0
xarray = arange(0, 10.5, 0.1)
sol = odeint(dy, y0, xarray)
# print(sol)
plt.plot(xarray, sol)
plt.show()
```

**高阶**：

高阶常微分方程，必须做**变量替换**，化为**一阶**微分方程组，再用 odeint 求数值解

> 之前在高等数学中学习过，这种换元，需要让**一阶导等于另外一个变量**，从而**二阶导就有了新的表现形式**，然后就可以求解了。
>
> 对应到scipy的求解中，需要定义==数组/向量==**表示y和y的各阶导**，如果求**二阶**的，这个向量就是`[y, y的一阶导]`（只写到一阶导是因为二阶导有新的表现形式，直接用来列等式即可），然后新定义两个变量`dy1`和`dy2`，列出等式即可

例如求解：$y''=1000(1-y^2)y'-y$

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720100759210.png" alt="image-20220720100759210" style="zoom:80%;" />

```python
from scipy.integrate import odeint
from numpy import arange
import matplotlib.pyplot as plt
from jupyterthemes import jtplot
jtplot.style()
def func(y, x):
    dy1 = y[1]
    dy2 = 1000*(1 - y[0]*y[0])*y[1] + y[0]
    return [dy1, dy2]
xarray = arange(0, 0.25, 0.01)
y0array = [0, 2]
sol = odeint(func, y0array, xarray)
print(sol)
y1, = plt.plot(xarray, sol[:, 0], label='y')
y1_1, = plt.plot(xarray, sol[:, 1], label='y')
plt.legend(handles=[y1, y1_1])
plt.show()
```

> 这里好像有问题，算了就这样吧

## 3 常/偏微分方程(组)及python求解

### 3.1 相关数学知识

多元函数：有序对集到数集的映射

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720105928598.png" alt="image-20220720105928598" style="zoom:80%;" />

多元函数的偏微分：**主元**法

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720110757394.png" alt="image-20220720110757394" style="zoom:80%;" />

多元函数的偏微分方程：$u(X),X=[x_1,x_2,...,x_n]$

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720111226462.png" alt="image-20220720111226462" style="zoom:80%;" />

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720111911415.png" alt="image-20220720111911415" style="zoom:80%;" />

多元函数的常/偏微分方程组：

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720112133592.png" alt="image-20220720112133592" style="zoom:80%;" />

### 3.2 python求解

在Python环境下搭建，一是采用基于基本原理自己写相关 函数，这样操作比较繁琐，但是对于整个的求解过程会比 较清晰明了。

第二就是利用python下面的ode（ordinary differential equation）求解包，熟悉相关的输入输出，就可以完成数值求解。基于这个demo，在不同方向领域可以套用不同的微分方程组模型，进行仿真求解。无论是常微分方程组还是偏微分方程组，使用的都是同一套思路， 就是用**差分代替微分**。

> 具体api调用方式见`scipy.ipynb`

<u>**python求解常微分方程组**</u>：

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720142605086.png" alt="image-20220720142605086" style="zoom:80%;" />

```python
from scipy.integrate import solve_ivp
from numpy import arange
def func(t, w):
    x = w[0]
    y = w[1]
    z = w[2]
    return [2*x - 3*y + 3*z, 4*x - 5*y +3*z, 4*x - 4*y + 2*z]
t_span = (0, 10)
w0array = [1, 2, 1]
teval = arange(1, 10, 1)
solve_ivp(func, t_span, w0array, t_eval=teval)
# solve_ivp(func, t_span, w0array)
```

> 图的话，学了matplotlib之后再画吧

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720143354523.png" alt="image-20220720143354523" style="zoom:80%;" />

```python
from scipy.integrate import solve_ivp
from numpy import arange
import matplotlib.pyplot as plt
from jupyterthemes import jtplot
jtplot.style()
def func(t, w):
    x = w[0]
    y = w[1]
    return [-x**3 - y, -y**3 + x]
tspan = (0, 100)
w0vector = [1, 0.5]
teval = arange(0, 100, 1)
yy = solve_ivp(func, tspan, w0vector, t_eval=teval)
t = yy.t
data = yy.y
plt.rcParams['font.sans-serif'] = ['Microsoft YaHei']
plt.plot(t, data[0, :])
plt.plot(t, data[1, :])
plt.xlabel("时间s")
plt.show()
```

<u>python求解偏微分方程(组)</u>：没讲？？？

## 4 微分方程案例

### 4.1 人口增长模型

#### 4.1.1 背景

人口问题是微分方程建模的一个典型案例。在高中生物里面我们接触过种群增长的**J型曲线和S型曲线**，现在的目的就是将这两种增长模型进行进一步**量化**。 

首先我们知道，一个种群的增长和它本身的**人口基数**有关，还与其**出生率**有关（不考虑**死亡的因素**下）。而种群的**人口基数又和出生率是有一定关系的**，是一个典型的**微分方程**案例。

人口增长主要可以用三种模型描述：

- ***Malthus Model*** 
- ***Logisitc Model*** 
- ***Leslie Model***

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720143708588.png" alt="image-20220720143708588" style="zoom:80%;" />

在模型中我们**假设**： 

- 不考虑**死亡率**对人口的影响，我们只考虑**净增长率** 
- 不考虑**人口迁移**对问题的影响，只考虑自然变化 
- 不考虑**重大突发事件**对人口的**突变**性影响 
- 不考虑**人口增长率变化的时滞性因素**

#### 4.1.2 Malthus模型

马尔萨斯模型假设**增长率**永远是个常数***r***，那么**一段时间**内增长个体有：
$$
x(t+\Delta t)-x(t)=x(t)\cdot r\Delta t
$$
按照**微分方程**的形式整理：
$$
\begin{cases}
\frac{dx}{dt}=xr\\
x(0)=x_0
\end{cases}
$$

> 能够抽象成微分方程的关键在于取“**一段时间**”这个**极小的增量**

最终解得：
$$
x(t)=x_0e^{rt}
$$
<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720144710382.png" alt="image-20220720144710382" style="zoom:80%;" />

思考这个模型存在的**局限性**： 

- **种群增长率真的是一个不随时间变化的常数吗？** 
- **种群基数**越大增长真的一定越快吗？ 

Malthus模型适用的典型例子： 

- 澳洲野兔、野猫的种群增长就是一个典型的Malthus过程

#### 4.1.3 :star:Logistic模型

现在对模型进行一些修正，假设增长率会随着种群数量增加而衰减，**种群最大的平衡数量**叫***K***，那么可以得到：
$$
r=r_0(1-\frac xK)~~~~~or~~~~~r=r_0(1-\beta t)\\
\begin{cases}
\frac {dx}{dt}=xr\\
x(0)=x_0
\end{cases}
$$

> K描述的其实就是种群“卷”的程度，K越小越“卷”，越“卷”越难生存（生存压力）

解得：
$$
x(t)=\frac K{1+(\frac K{x_0}-1)e^{-rt}}
$$
<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720145420861.png" alt="image-20220720145420861" style="zoom:80%;" />

Logistic模型的应用：

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720145456572.png" alt="image-20220720145456572" style="zoom:90%;" />

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720145558060.png" alt="image-20220720145558060" style="zoom:80%;" />

> 马尔萨斯和逻辑斯蒂都是宏观模型，考虑因素其实并不多，也有其他几类逻辑斯蒂模型：
>
> <img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720145539846.png" alt="image-20220720145539846" style="zoom:80%;" />
>
> > 时滞性就是说生存压力K并不是立刻起作用，而是在种群繁衍几代后才有用

### 4.2 放射问题

放射性物质半衰期的确定建模其实非常类似于**Malthus模型**，因为衰变的方程可以写作：
$$
\begin{cases}
\frac{dN}{dt}=-\lambda N\\
N(t_0)=N_0
\end{cases}
$$
于是我们很容易解出来：
$$
N(t)=N_0e^{-\lambda(t-t_0)}
$$
现在如果**用N反推t**，其实也很容易。比方说我取对数运算：
$$
t-t_0=-\frac1\lambda ln\frac N{N_0}
$$
这个公式即可用于确定放射性元素的**半衰期**

> 将$\frac N{N_0}$代入成$\frac 12$即可求半衰期

还有一种放射性问题是放射性元素的放射强度随着距离的一个变化。 

我们探究这样一个问题： 
例如福岛核废水事件中核电站向太平洋泄露了100吨核废料，如果不考虑洋流等因素的情况下 
查阅资料，建立**核废料浓度**与**扩散距离**、**扩散时间**的微分方程模型并建模 
这里可以假定**放射性强度**与**浓度**成正比，即：
$$
P=\lambda c
$$

### 4.3 新冠传播模型

#### 4.3.1 背景

在全国复工复产的大背景下，全民接种新冠疫苗，但目前新冠病毒的变 异种“德尔塔”、“奥密克戎”病毒卷土而来，相对于原来的新冠病毒传 染性更高，传播速度更快，且原有接种疫苗对其毫无作用。因此我们需 要对病毒传播初期、中期和后期的情况有充分的预测，以便于进行疫情 防控。 

新冠病毒传播速度快，感染时间短，能够迅速传染而且变异速度快很难做出疫苗。所以在这个问题当中要考虑**易感人群**，**无症状感染者**，**感染者**三者之间的平衡关系。

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720152241100.png" alt="image-20220720152241100" style="zoom:80%;" />

#### 4.3.2 特征

- 传播速度快，规模大，但是可以连续变化 
- 所有群体（绿码、黄码、红码）在人群中比例总和=1 
- 绿码少了多少黄码就多了多少，黄码少了多少红码就会多多少，红码康复多少绿码就会恢复多少，即有出就有进，**总体平衡**

#### 4.3.3 SI模型

> S： Susceptible     I：Infectious      E：Exposed       R：Recovered

SI 模型是最简单的传染病传播模型，把人群分为**易感者（S类）和患病者（I类）**两类，通过 SI 模型可以预测传染病高潮的到来；提高卫生水平、强化防控手段，降低病人的日接触率，可以推迟传染病高潮的到来。

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720152509976.png" alt="image-20220720152509976" style="zoom:67%;" />

**易感者**与**患病者**有效接触即被感染，变为**患病者**，无潜伏期、无治愈情况、无免疫力。

以一天作为模型的最小时间单元。**总人数为N**，不考虑人口的出生与死亡，迁入与迁出，此**总人数不变**。

**t 时刻两类人群占总人数的比率分别记为s(t)、i(t)**，**两类人群的数量为S(t)、I(t)**。

**初始**时刻 t=0 时，各类人数量所占**初始比率为s0、i0**。

每个患病者每天**有效接触的平均人数是 λ** ，即日**接触数**。

则可得以下微分方程
$$
\begin{cases}
N\frac{di}{dt}=\lambda s(t)Ni(t)\\
s(t)+i(t)=1
\end{cases}
$$

> 方程怎么来的？
>
> - 自变量取一段**极小的变化**，然后寻找因变量之间的关系，列等式
> - 这里找到的就是极小时间内**患病者增长的人数**
>
> 其实把dt乘过去更容易理解，dt和$\lambda$相乘代表dt时间内接触的人数

> 可以观察出，这其实属于Logisitc模型

```python
from scipy.integrate import odeint
from numpy import arange
import matplotlib.pyplot as plt

def di_dt(i, t, _lambda):
    return _lambda * (1 - i) * i
i0 = 1e-6
tarray = arange(0, 50, 1)
_lambda = 1
isol = odeint(di_dt, i0, tarray, args=(_lambda, ))

plt.plot(tarray, isol, ':.r', label='numerical')
plt.legend(loc='right')
plt.axis([0, 50, -0.1, 1.1])
plt.show()
```

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720163820850.png" alt="image-20220720163820850" style="zoom:80%;" />

#### 4.3.4 SIR模型

>S： Susceptible     I：Infectious      E：Exposed       R：Recovered

在 SI 模型基础上考虑病愈免疫的康复者（R 类）就得到 SIR 模型：

- 考察地区的总人数N不变，即不考虑生死或迁移;
- 人群分为易感者(S类)、患病者(|类) 和康复者(R类)三类;
- 易感者(S类)与患病者(I类) 有效接触即被感染，变为患病者(I类)；患病者(I类) 可被治愈，治愈后变为康复者；康复者(R类)获得终身免疫不再易感；无潜伏期;
- 将第t天时S类、I类、R类人群的占比记为s(t)、i(t).、r(t)，数量为S(t)、I(t)、R(t)；初始日期t = 0时，S类、I类、R类人群占比的初值为s~0~、i~0~、r~0~
- 日接触数$\lambda$：每个患病者每天有效接触的平均人数;
- 日治愈率μ：**每天被治愈的患病者人数占患病者总数的比例**，即平均治愈天数为1/μ
- 传染期接触数σ= λ/μ（用来求$\mu$），即每个患病者在**整个传染期**内有效接触的易感者人数。

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720164436075.png" alt="image-20220720164436075" style="zoom:80%;" />
$$
\begin{cases}
N\frac{ds}{dt}=-Ni(t)\lambda s(t)\\
N\frac{di}{dt}=Ni(t)\lambda s(t)-Ni(t)\mu\\
s(t)+i(t)+r(t)=1
\end{cases}
$$

> 取一极小段时间变化，由于这里是s、i、r三者有和为1的关系，所以关于其中的两个再列一个额外的方程即可，这里选择的是s和i（因为初始时其实没有康复者。如果非要列r的方程，那和为1的方程就不用列了，因为可以直接推出来）：
>
> - s很简单，因为易感人群的变化只和感染者有关
> - 列i的时候可以这样思考：`增量=收入-支出`，易感人群相当于收入，康复者相当于支出

```python
from scipy.integrate import odeint
from numpy import arange
import matplotlib.pyplot as plt

# sirfun = [s, i]
# r不涉及其导数，所以不放在微分方程组中求解，最后通过r=1-s-i求解即可
def func(sirfun, t, _lambda, mu):
    ds_dt = -_lambda*sirfun[0]*sirfun[1]
    di_dt = _lambda*sirfun[0]*sirfun[1] - mu*sirfun[1]
    return [ds_dt, di_dt]
i0 = 1e-6
s0 = 1 - i0 # 初始时没有所谓的“康复者”
sirfun0array = [s0, i0]
tarray = arange(0.0, 200, 1)
_lambda = 0.2
sigma = 2.5 # 这个就是用来求mu的
mu = _lambda/sigma
sirsol = odeint(func, sirfun0array, tarray, args=(_lambda, mu))

plt.xlabel('t')
plt.axis([0, 200, -0.1, 1.1])
plt.axhline(y=0, ls='--', c='c')
plt.plot(tarray, sirsol[:,1], '-r', label='i(t)-SIR')
plt.plot(tarray, sirsol[:,0], '-b', label='s(t)-SIR')
# 这里体现了对r的求解
plt.plot(tarray, 1 - sirsol[ :,1] - sirsol[ :,0], '-m', label='r(t)-SIR')
plt.legend(loc='best') 
plt.show()
```

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720165351924.png" alt="image-20220720165351924" style="zoom:80%;" />

#### 4.3.4 SEIR模型

SEIR 模型考虑存在易感者（Susceptible）、暴露者（Exposed）、患病者（Infectious）和康复者（Recovered）四类人群，适用于具**有潜伏期**、**治愈后获得终身免疫的传染病**。**易感者（S 类）被感染后成为潜伏者（E类）**，随后发病成为患病者（I 类），治愈后成为康复者（R类）。这种情况更为复杂，也更为接近实际情况。

**易感者（S 类）与患病者（I 类）有效接触即变为暴露者（E 类）**，暴露者（E 类）经过平均潜伏期后成为患病者（I 类）；患病者（I 类）可被治愈，治愈后变为康复者（R 类）；康复者（R 类）获得终身免疫不再易感

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720191741562.png" alt="image-20220720191741562" style="zoom:67%;" />

增加常量**日发病率**$\delta$：**每天发病成为患者的潜伏者占潜伏者总数的比例**

微分方程：
$$
\begin{cases}
N\frac{ds}{dt}=-Ni(t)\lambda s(t)\\
N\frac{de}{dt}=Ni(t)\lambda s(t)-Ne(t)\delta\\
N\frac{di}{dt}=Ne(t)\delta-Ni(t)\mu\\
s(t)+e(t)+i(t)+r(t)=1
\end{cases}
$$

> 这里是对s、e、i列方程：
>
> - s减少量的等式：虽然引入了疑似病例，但引起易感人群数量变化的**因素**还是感染者，**本质没有变**，所以方程也没变
> - e和i的增量等式：都有两个影响因素，依然是“收入”和“支出”的思考方式
>
> r的话根据seir和为1去求即可
>
> > 这里可以进一步思考，这其实是一种**单影响因素**和**多影响因素**变量的列方程套路

```python
from scipy.integrate import odeint
from numpy import arange
import matplotlib.pyplot as plt

# seirfun = [s, e, i]
def func(seirfun, t, _lambda, mu, delta):
    ds_dt = -_lambda*seirfun[0]*seirfun[2]
    de_dt = _lambda*seirfun[0]*seirfun[2] - seirfun[1]*delta
    di_dt = seirfun[1]*delta - mu*seirfun[2]
    return [ds_dt, de_dt, di_dt]
i0 = 1e-6
e0 = 1e-3
s0 = 1 - i0 - e0
seirfun0array = [s0, e0, i0]
tarray = arange(0.0, 300, 1)
_lambda = 0.3
mu = 0.06
delta = 0.03
seirsol = odeint(func, seirfun0array, tarray, args=(_lambda, mu, delta))

plt.xlabel('t')
plt.axis([0, 300, -0.1, 1.1])
plt.axhline(y=0, ls='--', c='c')
plt.plot(tarray, seirsol[:,0], '-r', label='s(t)-SIR')
plt.plot(tarray, seirsol[:,1], '-g', label='e(t)-SIR')
plt.plot(tarray, seirsol[:,2], '-b', label='i(t)-SIR')
plt.plot(tarray, 1 - seirsol[ :,0] - seirsol[ :,1] - seirsol[ :,2], '-k', label='r(t)-SIR')
plt.legend(loc='right') 
plt.show()
```

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720200047817.png" alt="image-20220720200047817" style="zoom:80%;" />

> 关于SEIR模型的进一步思考：
>
> <img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220720200251851.png" alt="image-20220720200251851" style="zoom:67%;" />
>
> - 由于病毒的变异，康复者可能再次成为易感者
> - 关于死亡病例的影响
> - 易感者接种疫苗后也相当于康复者

### 4.4 捕食者模型

考虑这样一个捕鱼问题，海洋中有两种鱼类，一种肉食鱼以另一种草食鱼为食。 还记得人口的逻辑斯蒂模型吗？
$$
\frac{dy}{dt}=yr_0(1-\beta t)
$$

> **因素t**会影响**增长率**

现在我们考虑多种群之间的相互作用，对其进行进一步修正：
假设大海中有食用鱼生存的足够资源，可假设食用鱼独立生存将按增长率为r1的指数律增长，由于捕食者的存在，食用鱼数量因而减少，设减少的速率与两者数量的乘积成正比
$$
\begin{cases}
\frac{dx_1}{dt}=x_1(r_1-\lambda_1 x_2)\\
\frac{dx_2}{dt}=x_2(r_2-\lambda_2 x_1)
\end{cases}
$$

> 这也是Lotka-Volterra模型

> 捕食者与被捕食的数量者互相有影响，这个因素要考虑进去；
>
> 上面logistic模型中的那个**因素t**，在这里可以换成“**对方**”，对于捕食者的增长率方程来说，就换成被捕食者，对于被捕食者的增长率方程来说，就换成捕食者；
>
> r和$\lambda$可能是负的，最开始的增长率不好说（我没想明白），$\lambda$代表二者之间的影响，直观来讲，被捕食者越多，捕食者也会越多，所以**捕食者**的一般都会**取负数**

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220721092250724.png" alt="image-20220721092250724" style="zoom:80%;" />

进一步探讨，令$\frac{dx_1}{dt}=0,\frac{dx_2}{dt}=0$，可以找到系统的平衡点/不动点(fixed point)

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220721101618891.png" alt="image-20220721101618891" style="zoom:80%;" />

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220721102316154.png" alt="image-20220721102316154" style="zoom:75%;" />

> 这种图叫“**相轨图**”

```python
from scipy.integrate import odeint
from numpy import linspace
import matplotlib.pyplot as plt

def derivative(x, t, r1, r2, lambda1, lambda2):
    x1 = x[0]
    x2 = x[1]
    dx1_dt = x1*(r1 - lambda1*x2)
    dx2_dt = x2*(r2 - lambda2*x1)
    return [dx1_dt, dx2_dt]
r1 = 1
r2 = -1
lambda1 = 1
lambda2 = -1
x10 = 4
x20 = 2
X0 = [4, 2]
trange = linspace(0, 30, 1000)
res = odeint(derivative, X0, trange, args=(r1, r2, lambda1, lambda2))

plt.figure()
plt.grid()
plt.title('odeint method')
plt.plot(trange, res.T[0], 'xb', label='Deer')
plt.plot(trange, res.T[1], '+r', label='Wolves')
plt.xlabel('Time t, [days]')
plt.ylabel('Population')
plt.legend()
plt.show()

plt.figure()
IC = linspace(1., 6., 21)
for deer in IC:
    X0 = [deer, 1.]
    Xs = odeint(derivative, 
                          X0, 
                          trange, 
                          args=(r1, r2, lambda1, lambda2))
    plt.plot(Xs.T[0], Xs.T[1], '-', label='$x_0=$'+str(X0[0]))
plt.xlabel('Deer')
plt.ylabel('Wolves')
plt.legend()
plt.title('Deer vs Wolves')
plt.show()
```

## 5 差分方程与数值方法

### 5.1 差分方程相比微分方程

相当于是**离散**与**连续**的关系

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220721104908649.png" alt="image-20220721104908649" style="zoom:80%;" />

微分方程：

- 思想简单，条件纯粹，微元分析，建模容易。能够考虑到多变量构成的系统。但模型较为原始，求解并不容易。 

差分方程：

- 是对连续系统的离散化处理，能够考虑更多因素。有时求解也并不容易，但整体比微分方程应用更为宽泛。

### 5.2 人口模型的新讨论

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220721105448946.png" alt="image-20220721105448946" style="zoom:80%;" />

- Malthus和Logistic模型都是连续的模型 

- Leslie矩阵只能离散式做迭代 

- Malthus模型和Logistic模型考虑的因素没有Leslie模型更多，但Leslie模型操作也比较简单

### 5.3 数值计算方法

> 还好学校里讲了计算方法，不然根本听不懂这老师在讲啥

#### 5.3.1 梯度下降

<u>寻找极值</u>：沿着**梯度方向**一步一步走

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220721110525997.png" alt="image-20220721110525997" style="zoom:80%;" />

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220721111113905.png" alt="image-20220721111113905" style="zoom:80%;" />

<u>梯度下降法如何**计算梯度**？</u>

> 求解梯度的三种不同形式

- **批量**梯度下降法：

  <img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220721110858492.png" alt="image-20220721110858492" style="zoom:80%;" />

- **随机**梯度下降法：

  <img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220721110907173.png" alt="image-20220721110907173" style="zoom:80%;" />

  > 在神经网络中使用较多

- **小批量**梯度下降法：

  <img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220721110917507.png" alt="image-20220721110917507" style="zoom:80%;" />

#### 5.3.2 牛顿法

<u>寻找极值</u>：迭代找到导数为0的点

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220721111253686.png" alt="image-20220721111253686" style="zoom:80%;" />

<u>牛顿法计算过程</u>：

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220721111340573.png" alt="image-20220721111340573" style="zoom:80%;" />

> $H_k$指的是矩阵：
> $$
> \begin{pmatrix}
> \frac{\partial^2 f}{\partial x^2}~~~\frac{\partial^2 f}{\partial x\partial y}\\
> \frac{\partial^2 f}{\partial x\partial y}~~~\frac{\partial^2 f}{\partial y^2}
> \end{pmatrix}
> $$
> 一元函数求一阶导$\rarr$二元函数梯度
>
> 一元函数求二阶导$\rarr$二元函数Hessian矩阵

#### 5.3.3 欧拉法

> 差商代替导数

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220721113248954.png" alt="image-20220721113248954" style="zoom:80%;" />

#### 5.3.4 Runge-Kutta法

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220721113328858.png" alt="image-20220721113328858" style="zoom:80%;" />

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220721113359569.png" alt="image-20220721113359569" style="zoom:80%;" />

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220721113441425.png" alt="image-20220721113441425" style="zoom:80%;" />

### 5.4 Python提供的数值计算方法

常见方法例如二分法、牛顿法、拟牛顿法、梯度下降、带动量梯度下降、龙格库塔、欧拉法、改进欧拉、梯形法都有集成。 

使用时参考函数的文档即可，这里也可以手动编写改进欧拉法、龙格库塔等程序，其实并没有那么可怕。（？？？）

## 6 数学建模的程序编写

### 6.1 数学建模程序的种类

- 数值计算
- 绘图

### 6.2 数值计算

- 文件读写
- 基本程序流程设计
- 使用面向对象的编程思想：封装
- 尝试复现经典算法（再说吧）
- 尽可能调用现成的工具包和代码
  - 自己之前写过的可以积累起来，改改就用
  - 网上找的代码资源（CSDN、知乎、博客园、简书、githubgitee）
- 尽可能节约时间和空间，并行化计算会比循环更快
  - 使用`numpy pandas`等
  - 利用数据结构加快速度，如`dict`读取的速度较快

# 数据处理的基本策略

## 1 什么是数据

### 1.1 什么是数

数字是人类用于表示计数的工具，原始时代就有了

毕达哥拉斯说：“万物皆数”

除了“有几个”，各种物理量、化学量也可以用数表示

数包括自然数、整数、正数、负数、实数、有理数、复数等

实际上，有很多你想象不到的东西都可以**数化**

### 1.2 什么是数据

我们每个人都生活在数据当中 

抖音的点击量是数据，视频本身是数据，评论是数据 

> 视频本身就是图像的堆积，图像可以数字化

甚至每个人的电话号码，姓名，QQ号都可以称为数据 

数据不仅仅是一张excel表格这么简单 

也不是只有excel表格才配称为数据 

什么是数据这个问题上我们不学意大利人不吃菠萝披萨

凡是**能够用数来量化的信息**都可以称为数据 

数字表格是数据：财报，成绩单，工业仪表记录…… 

图像与视频也是数据：数字图像处理把像素点数字化 

自然语言文本也是数据：微博文本，头条新闻，甚至唐诗 

波形信号更是数据：地震波，电磁波，机械振动，音乐…… 

数据的格式也有很多： 

- jpg,png,mp4,avi,txt,csv,tsv,xlsx,json,txt……

### 1.3 数据的基本特征

包含了**可以量化的信息**，能够做分析 

能够通过一些对应的手段用数字进行量化 

能够从数据中提取出有用信息 

数据能够反映描述对象的基本情况 

数据能够被计算机读取、写入、存储、处理、分析、管理

### 1.4 数据科学

<img src="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AF%BC%E8%AE%BA.assets/image-20220722090722481.png" alt="image-20220722090722481" style="zoom:67%;" />

- 数据存储
- 数据处理：多快好省
- 数据分析
- 数据管理
- 数据应用

### 1.5 数据的属性

在前面的学习中我们知道离散的概念与连续的概念 

- **离散**：取值是有限的，不光是0-1规划这样的数字，{猫，狗}这样的有限词汇集合也可以构成离散特征 
- **连续**：取值是无限的，通常为实数，比如173.52cm等 

通常数据的属性就是**离散类属性**和**连续类属性**两个大类

### 1.6 数据量与数据维度

数据量：

- 数据量从直观而言，你可以认为在一个excel表格里面有多少行 
- 也可以认为这份数据在计算机内占有多大的一块存储空间 
- 依个人经验，小于1000行的excel表格都只配叫小体量数据、1000-20000算中体量、20000-1000000是大体量（excel的上限就一百多万） 、一百万以上的时候可以考虑选择使用云服务资源 
- 100以下是微数据，这种情况下不要想机器学习这些花哨的方法

数据维度：

- 你可以理解为excel表格有多少列 
- 每一列分别是什么数据量，属性如何 
- 如果是图像数据那么这个图像的大小多少 
- 如果是文本数据需要把文本做向量化 
- 如果是信号数据那么通常来讲维度并不会太高 
- 数据稀疏：拿你们最熟悉的excel举例子：列/行>0.5的时候

### 1.7 数据的模态

> 描述数据的一种形式

数值表，文本，图像，视频，音频等都可以作为**模态** 

- 如果两个数据集里面的**模态不一样**，但都是对**同一个事物**做描述，那么这两个数据集是**异质模态** 

- 如果一个数据包含不同模态的信息，或者模型利用不同模态的数据综合分析，我们称其为**多模态**

  > 比如视频与音频的结合

### 1.8 数据库与爬虫

爬虫是就是一个**程序**，这个程序的任务就是从给出的一组种子***UR***L开始爬取网页，并通过网页间的**链接**爬取更多的网页，根据爬虫任务的需求，最终可能会爬取整个互联网的网页。 

数据库是**数据管理的有效技术**，是由**一批数据构成的集合**，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映客观事物间的本质联系。数据库能有效地帮助一个组织或企业科学地管理各类信息资源。

### 1.9 表格数据

excel,csv,tsv数据 ：

- 但是excel编码单一，而且行数上限**只有108万** 

  > 一则英式笑话：英国21年年初没有任何新增COVID-19病例 ,
  >
  > 因为Microsoft Excel封顶108万个病例，新增的数据根本导不出来，笑死 

- csv就没有这个**上限限制**了，即使转成txt也可以读取 
- csv用逗号分割，tsv用Tab键分割

excel的基本使用：

- 输入数据 
- 统计数据 
- 求和、筛选等操作 
- 绘图 
- ...

## 2 数据预处理



## 3 插值与拟合



## 4 数据可视化
