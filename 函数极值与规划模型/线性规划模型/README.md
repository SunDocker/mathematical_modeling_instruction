## 1 线性规划模型

### 1.1 概述

<u>回顾中学的线性规划</u>：

- 我们可能还记得中学课本里面有一个边缘化的知识——==**线性规划**==
  大家还能回忆起线性规划究竟是用来做什么的吗？
  求一个**线性目标函数**在**线性可行域**内的：==**最值问题**==

  <img src="%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B.assets/image-20220707145446478.png" alt="image-20220707145446478" style="zoom:50%;" />

- 线性规划的典型应用有哪些？

  - 配送运输问题，选大车还是小车
  - 生产规划问题，每种原料各买多少
  - 几何切割问题，切割长宽多少
  - 买卖利润问题，这种方案下我能挣多少

- 关于中学线性规划解法的思考

  - 以前我们做的时候可以直接带交点进去算
  - **问题的线性**和**条件的线性**，即**线性特征**，让我们可以这样去做

- 给中学的线性规划增加难度：

  - 有更多的**变量**，不只两个，坐标系画不出来
  - 目标函数变成**非线性**
  - 可行域中不只有**不等式**，还有**等式**
  - 变量还有一个特殊的**约束**

  >你还会解这样的问题吗？最优解还一定会在交点或边界取到吗?？还能通过作图求吗？最优解还一定存在吗？

- ==线性规划的本质==：

  - ==问题是线性的==
  - ==约束是线性的==

### 1.2 线性代数基本概念

<u>向量</u>：

- n维向量
- 不只三维，还可以有更多维度
- 引入n维向量的目的：
  - 通过**代数方法**解决**几何问题**

<u>向量的基本运算</u>：
<img src="%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B.assets/image-20220707150842268.png" alt="image-20220707150842268" style="zoom:67%;" />

> 内积结果向量的方向可以用**右手定则**去判断

<u>矩阵</u>：

- 数的集合是向量，向量的集合形态就是矩阵
- 向量数乘：
  <img src="%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B.assets/image-20220707151059918.png" alt="image-20220707151059918" style="zoom:67%;" />

<u>行列式</u>：

- 行列式就是一个数，可以理解为**方阵的模**

- 二阶和三阶行列式有**公式**

- 高阶的可以用**展开定理**：

  <img src="%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B.assets/image-20220707151232606.png" alt="image-20220707151232606" style="zoom:60%;" />

  > 代数余子式：
  >
  > <img src="%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B.assets/image-20220707151613215.png" alt="image-20220707151613215" style="zoom:80%;" />

<u>矩阵的运算</u>：

- 线性运算
  <img src="%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B.assets/image-20220707152025184.png" alt="image-20220707152025184" style="zoom:67%;" />

  > 矩阵的线性运算与向量类似，因为本身就是向量的线性组合

- 乘法
  <img src="%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B.assets/image-20220707152122636.png" alt="image-20220707152122636" style="zoom:67%;" />

- 逆运算

  <img src="%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B.assets/image-20220707152158217.png" alt="image-20220707152158217" style="zoom:60%;" />

<u>利用`python`进行矩阵的相关运算</u>：

- 基本运算

  - 见python数据分析之numpy

- 求一次方程组的解

  ```python
  import numpy as np
  
  A = np.array([[10, -1, -2],
                [-1, 10, -2],
                [-1, -1, 5]])
  b = np.array([72, 83, 42])
  # inv_A = np.linalg.inv(A)
  # x = inv_A @ B
  x = np.linalg.solve(A, b)
  print(x)
  
  from sympy import symbols, Eq, solve
  
  x, y, z = symbols('x y z')
  eqs = [Eq(10 * x - y - 2 * z, 72),
         Eq(-x + 10 * y - 2 * z, 83),
         Eq(-x - y + 5 * z, 42)]
  print(solve(eqs, [x, y, z]))
  ```

  - 主要通过scipy sympy numpy这三个库就能实现各种各样的一次方程组求解。

  - `sympy`主要用于**符号解**

    > 目前的理解就是，有不只一个解的线性方程组需要用**符号解**去求解

  - `numpy`和`scipy`主要用于**数值解**

### 1.3 线性规划的标准形式

#### 1.3.1 规范形式

> 程序设计时应用较多

目标函数是决策变量的线性组合，有不等关系，等量关系，变量范围，求目标极小值

<img src="%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B.assets/image-20220711211604247.png" alt="image-20220711211604247" style="zoom:67%;" />

- **不等式**组条件的矩阵化 
- **方程**组条件的矩阵化 
- 每个变量自己的**取值范围** 
- **目标函数**的向量化 
- 求**极值** 

==要点：决策变量，目标函数，约束条件==

#### 1.3.2 一般形式

> 遇到代数推导等处理特殊问题时会用

<img src="%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B.assets/image-20220711212039455.png" alt="image-20220711212039455" style="zoom:80%;" />

> X到$\overset{\sim}{X}$的解释：
>
> <img src="%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B.assets/image-20220711212100952.png" alt="image-20220711212100952" style="zoom:67%;" />

#### 1.3.3 对线性规划标准形式的理解

- 问题是线性的极值
- 约束条件本应该是小于等于，这是通用的，改成等于是利用问题的线性 
- 存在不等约束时变换可应用**松弛变量** 
- 规划问题的核心在于==决策变量，目标函数和约束条件==

#### 1.3.4 求解简单线性规划问题举例

![image-20220711212832756](%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B.assets/image-20220711212832756.png)

一些处理：

- 规范形式是极小值，这里目标函数要极大值，可以加个负号
- 规范形式的不等式都是小于等于，这里有大于等于，可以加个负号

`scipy.optimize.linprog`的调用格式：

```python
scipy.optimize.linprog(目标函数的系数向量, 
                       不等式的描述方式（系数，b）, 
                       方程的描述方式（系数，b）, 
                       变量约束)
```

代码：

```python
import numpy as np
from scipy.optimize import linprog

c = np.array([-2, -3, 5])
Aeq = np.array([[1, 1, 1]])
beq = np.array([7])
A = np.array([
    [-2, 5, -1],
    [1, 3, 1],
])
b = np.array([-10, 12])
x1, x2, x3 = (0, None), (0, None), (0, None)

res = linprog(c, A, b, Aeq, beq, (x1, x2, x3))
print(res)
print(-res.fun)
print(res.x)

```

### 1.4 相关数学原理

#### 1.4.1 单纯形法

回顾中学阶段，我们求线性规划的时候都是解方程然后直接带点进去，直线与直线之间两两相交就有交点，这其实就是**单纯形法**的雏形。现在的线性规划方程组是不一定存在交点或者不唯一解的。 

线性代数中我们会知道：解方程组的时候是可以用**向量和基分解的思想**解决的 

==**单纯形法**的思想就是：**固定变量**，不断变换**基向量**求方程组的解带入，看是不是最优解，不是就更新迭代现阶段的解==

这就可以解释为什么在线性规划问题中要引入**松弛变量**

- 为什么我们需要引入松弛变量呢？原因很简单，因为**单纯形法**要求约束条件都为等式（且要求所有变量非负），那么要是有不等式约束怎么办？那我们就把不等式约束**通过引入松弛变量变为等式约束**，这样一来带有不等式约束的线性规划问题就也能用单纯形法解决了。

<img src="%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B.assets/image-20220711215343503.png" alt="image-20220711215343503" style="zoom:70%;" />

> 总结：什么情况下在线性规划中引入松弛变量？
>
> - 当你需要将线性规划化成标准形式/一般形式的时候
>
> - 当你遇到**绝对值**问题的时候
>
>   > 比如，可以将$|x_1-x_2|\le2$改成$x_1=x_2+\epsilon,-2\le\epsilon\le2$
>
> - 当你遇到不等式过多甚至到了**非线性**的不等关系的时候

#### 1.4.2 蒙特卡洛法

> 单纯形法求解比较精确，如果只是想要一个可行解，可以用蒙特卡洛法

蒙特卡洛方法就是在**可行域范围内生成大批量随机数据点**，观测这些数据点在什么位置取得近似最优。但是生成点因为是随机的，所以肯定是要生成大批量数据去做计算的，然后求出来的也只是数值的近似最优解，更多的适用于解**非线性问题**，线性问题是能得到准确解的。

> 总结：引入松弛变量的规划求解
>
> - 蒙特卡洛法 
> - 分支定界法 
> - 单纯形法